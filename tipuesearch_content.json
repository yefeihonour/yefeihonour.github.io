{"pages":[{"url":"https://yefeihonour.github.io/Extract-0.html","text":"什么是线程 什么是线程？线程与进程与有什么关系？这是一个非常抽象的问题，也是一个特别广的话题，涉及到非常多的知识。我不能确保能把它讲的话，也不能确保讲的内容全部都正确。即使这样，我也希望尽可能地讲通俗一点，讲的明白一点，因为这是个一直困扰我很久的，扑朔迷离的知识领域，希望通过我的理解揭开它一层一层神秘的面纱。 任务调度 线程是什么？要理解这个概念，须要先了解一下操作系统的一些相关概念。大部分操作系统(如Windows、Linux)的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于 CPU 的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在\"同时进行\"，这也就是我们所说的并发(别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行)。 多任务运行过程的示意图如下： 进程 我们都知道计算机的核心是 CPU ，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序侧是具有某种功能的程序，程序是运行于操作系统之上的。 进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序、数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块(Program Control Block，简称 PCB )，包含进程的描述信息和控制信息，是进程存在的唯一标志。 进程具有的特征： 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的； 并发性：任何进程都可以同其他进程一起并发执行； 独立性：进程是系统进行资源分配和调度的一个独立单位； 结构性：进程由程序、数据和进程控制块三部分组成。 线程 在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。 后来，随着计算机的发展，对 CPU 的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程 ID 、当前指令指针( PC )、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。 进程与线程的区别 前面讲了进程与线程，但可能你还觉得迷糊，感觉他们很类似。的确，进程与线程有着千丝万缕的关系，下面就让我们一起来理一理： 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位； 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线； 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见； 调度和切换：线程上下文切换比进程上下文切换要快得多。 线程与进程关系的示意图： 总之，线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可用于实现并发。 在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程(Lightweight Process， LWP ）。 后来，随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念——线程，一般一个进程会有多个(也可是一个)线程。 多线程与多核 上面提到的时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说\"同一时间点只有一个任务在执行\"。那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？ 其实\"同一时间点只有一个任务在执行\"这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。 多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。内核线程（Kernel Thread， KLT ）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。 现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的 CPU 数量是实际物理 CPU 数量的两倍，如你的电脑是双核四线程，打开\"任务管理器\\性能\"可以看到4个 CPU 的监视器，四核八线程可以看到8个 CPU 的监视器。 超线程技术就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了 CPU 的闲置时间，提高的 CPU 的运行效率。这种超线程技术(如双核四线程)由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process， LWP ），轻量级进程就是我们通常意义上所讲的线程(我们在这称它为用户线程)，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。用户线程与内核线程的对应关系有三种模型：一对一模型、多对一模型、多对多模型，在这以4个内核线程、3个用户线程为例对三种模型进行说明。 一对一模型 对于一对一模型来说，一个用户线程就唯一地对应一个内核线程(反过来不一定成立，一个内核线程不一定有对应的用户线程)。这样，如果 CPU 没有采用超线程技术(如四核四线程的计算机)，一个用户线程就唯一地映射到一个物理 CPU 的线程，线程之间的并发是真正的并发。一对一模型使用户线程具有与内核线程一样的优点，一个线程因某种原因阻塞时其他线程的执行不受影响；此处，一对一模型也可以让多线程程序在多处理器的系统上有更好的表现。 但一对一模型也有两个缺点：1.许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制；2.许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。 多对一模型 多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，因此相对一对一模型，多对一模型的线程切换速度要快许多；此外，多对一模型对用户线程的数量几乎无限制。但多对一模型也有两个缺点：1.如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了；2.在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。 多对多模型 多对多模型结合了一对一模型和多对一模型的优点，将多个用户线程映射到多个内核线程上。多对多模型的优点有：1.一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；2.多对多模型对用户线程的数量没有限制；3.在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。 在现在流行的操作系统中，大都采用多对多的模型。 查看进程与线程 一个应用程序可能是多线程的，也可能是多进程的，如何查看呢？在Windows下我们只须打开任务管理器就能查看一个应用程序的进程和线程数。按\"Ctrl+Alt+Del\"或右键快捷工具栏打开任务管理器。 查看进程数和线程数： 在\"进程\"选项卡下，我们可以看到一个应用程序包含的线程数。如果一个应用程序有多个进程，我们能看到每一个进程，如在上图中，Google的chrome浏览器就有多个进程。同时，如果打开了一个应用程序的多个实例也会有多个进程，如上图中我打开了两个cmd窗口，就有两个cmd进程。如果看不到线程数这一列，可以在点击\"查看\\选择列\"菜单，增加监听的列。 查看 CPU 和内存的使用率： 在性能选项卡中，我们可以查看 CPU 和内存的使用率，根据 CPU 使用记录的监视器的个数还能看出逻辑处理核心的个数，如我的双核四线程的计算机就有四个监视器。 线程的生命周期 当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。 在单个处理器运行多个线程时，并发是一种模拟出来的状态。操作系统采用时间片轮转的方式轮流执行每一个线程。现在，几乎所有的现代操作系统采用的都是时间片轮转的抢占式调度方式，如我们熟悉的Unix、Linux、Windows及Mac OS X等流行的操作系统。 我们知道线程是程序执行的最小单位，也是任务执行的最小单位。在早期只有进程的操作系统中，进程有五种状态，创建、就绪、运行、阻塞(等待)、退出。早期的进程相当于现在的只有单个线程的进程，那么现在的多线程也有五种状态，现在的多线程的生命周期与早期进程的生命周期类似。 进程在运行过程有三种状态： 就绪 、 运行 、 阻塞 ，创建和退出状态描述的是进程的创建过程和退出过程。 创建：进程正在创建，还不能运行。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间； 就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来； 运行：此线程正在执行，正在占用时间片； 阻塞：也叫等待状态，等待某一事件(如 IO 或另一个线程)执行完； 退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。 创建：一个新的线程被创建，等待该线程被调用执行； 就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来； 运行：此线程正在执行，正在占用时间片； 阻塞：也叫等待状态，等待某一事件(如 IO 或另一个线程)执行完； 退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源。","tags":"Linux","title":"[摘记] 从操作系统的角度，聊聊线程与进程"},{"url":"https://yefeihonour.github.io/Linux-commond.html","text":"文件和目录管理 命令 cd 命令 cd 是用来改变用户所在目录的，如果后面参数都不跟，就会进入当前用户的根目录 可以使用 pwd 查看当前所在目录 $ cd /tmp # 跳转目录 $ pwd /tmp $ cd # 进入用户根目录 $ pwd /home/kosmos $ cd .. # 进入当前目录的上一级目录 $ pwd /home $ cd - # 返回上一次工作目录 $ pwd /home/kosmos 命令 mkdir 命令 mkdir 用于创建目录，是 make directory 的缩写。 命令格式： mkdir [-mp] [目录名称] -m 指定创建目录的权限（不常用） -p 递归创建指定目录，当目录名称中包含子目录时，不会报错 $ mkdir /temp/test/123 mkdir: cannot create directory ‘/temp/test/123': No such file or directory $ mkdir -p /temp/test/123 # 递归创建目录 $ ls /temp/test 123 命令 rmdir 命令 rmdir 用于删除空目录。 rmdir 和 mkdir 有相同的选项 -p ，它同样可以级联删除一串目录，但某一个目录中还有其他子目录或者子文件时，会提示目录非空，无法删除。 命令 rm rm [-rf] [文件或目录] rm有很多参数： -r 删除目录的选项，等同于 rmdir -f 表示强制删除。它不会询问是否删除，而是直接删除。 如果后面跟一个不存在的文件或者目录，则不会报错。 命令 cp cp [选项] [来源文件] [目的文件] -r 如果要复制一个目录，则必须加 -r 命令 touch touch [文件名] 如果文件存在，则会改变这个文件的访问时间；如果文件不存在，则会创建这个文件 命令 mv mv [选项] [源文件或目录] [目标文件或目录] 1.目标文件是目录 目录存在: 把源文件或目录移动到该目录中 目录不存在: 把源目录重命名为给定的目标文件名 2.目标文件是文件 文件存在: 询问是否覆盖原文件 文件不存在: 把源文件重命名为给定的目标文件 该命令常用于对当前文件的重命名操作 查看文档命令 命令 cat 命令 cat 用于查看一个文件的内容并显示在屏幕上，cat后面可以不加任何选项直接跟文档名 // -n 查看文档时，把行号也显示到屏幕上 // -A 显示所有的内容，包括特殊字符 $ echo \"111\" > file # 将内容写入到文件中 $ echo \"222\" >> file # 将内容追加到文件中 $ cat file 111 222 $ cat -n file # 打印行号 1 111 2 222 $ cat -A file # 显示全部 111$ 222$ 命令 tac 命令 tac 和命令 cat 一样，也是把文件的内容打印到屏幕上，不过是先显示最后一行，然后从后向前显示，最后才显示第一行 命令 more 命令 more 查看文件内容，后面直接跟文件名。 当文件内容太多，一屏不能全部显示时，使用 more 命令，按 空格 键可以分屏浏览。 按 q 可以提前退出浏览 命令 less 命令 less 与命令 more 用法功能相似 按 j 向下移动一行 按 k 向上移动一行 命令 head head [-n] [文件名] 命令 head 用于显示文件的前 10 行，后面直接跟文件名 $ head -n 5 /Desktop/file.txt $ head -n5 /Desktop/file.txt $ head -5 /Desktop/file.txt 命令 tail tail [-n] [文件名] 命令 tail 用于显示文件的后 10 行，后面直接跟文件名 $ head -n 5 /Desktop/file.txt $ head -n5 /Desktop/file.txt $ head -5 /Desktop/file.txt","tags":"Linux","title":"[Linux] 常用命令笔记"},{"url":"https://yefeihonour.github.io/Reverse-Linked-List.html","text":"Questions Difficulty: Easy Reverse a singly linked list. Hint A linked list can be reversed either iteratively or recursively. Could you implement both? Coding python-1 # -*- coding: utf-8 -*- # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution ( object ): def reverseList ( self , head ): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head is None or head . next is None : return head pre , p , next = head , head , None while p != None : pre , p . next , next = p , pre , p . next # next = p.next # p.next = pre # pre = p p = next head . next = None return pre python-2 # -*- coding: utf-8 -*- # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution ( object ): def reverse ( self , p ): if p . next is None : return p else : next = p . next tail = self . reverse ( next ) next . next = p return tail def reverseList ( self , head ): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head is None or head . next is None : return head else : tail = self . reverse ( head ) head . next = None return tail","tags":"Linux","title":"LeetCode [206] Reverse Linked List"},{"url":"https://yefeihonour.github.io/Remove-Linked-List-Elements.html","text":"Questions Difficulty: Easy Remove all elements from a linked list of integers that have value val. Example Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6 , val = 6 Return: 1 --> 2 --> 3 --> 4 --> 5 Coding python # -*- coding: utf-8 -*- # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution ( object ): def removeElements ( self , head , val ): \"\"\" :type head: ListNode :type val: int :rtype: ListNode \"\"\" if head is None : return head while head . val == val : head = head . next if head == None : return head p = head while p . next != None : if p . next . val == val : p . next = p . next . next else : p = p . next if p . val == val : p = p . next return head","tags":"Linux","title":"LeetCode [203] Remove Linked List Elements"},{"url":"https://yefeihonour.github.io/Reverse-Words-in-a-String.html","text":"Questions Difficulty: Medium Given an input string, reverse the string word by word. For example, Given s = \"the sky is blue\" , return \"blue is sky the\" . For C programmers: Try to solve it in-place in O(1) space. Clarification : What constitutes a word? A sequence of non-space characters constitutes a word. Could the input string contain leading or trailing spaces? Yes. However, your reversed string should not contain leading or trailing spaces. How about multiple spaces between two words? Reduce them to a single space in the reversed string. Coding C #include <stdio.h> #include <stdlib.h> #include <string.h> /* * 反转字符串的指定长度 */ void reverse ( char * s , int start , int end ){ char t ; for (; start < end ; start ++ , end -- ){ t = s [ start ]; s [ start ] = s [ end ]; s [ end ] = t ; } } void reverseWords ( char * s ) { if ( s == NULL ){ return ; } int n = strlen ( s ); int i = 0 , j = strlen ( s ) - 1 , t = 0 , r = 0 ; /* 消除字符串末尾的空格 */ while ( s [ j ] == ' ' ){ s [ j ] = '\\0' ; j -= 1 ; } /* 消除字符串开始的空格 */ while ( s [ i ] == ' ' ){ i ++ ; } n = strlen ( s ); r = t + i ; while ( n > 0 ){ /* 消除字符串中间的多个空格 */ while ( s [ r ] == ' ' && s [ r + 1 ] == ' ' ){ r ++ ; } s [ t ] = s [ r ]; t ++ ; r ++ ; n -- ; } s [ t ] = '\\0' ; i = 0 ; n = strlen ( s ); while ( i < n ){ j = i ; while ( j < n ){ if ( s [ j ] == ' ' ){ /* 使用单引号表示空格字符 */ break ; } else { j ++ ; } } reverse ( s , i , j - 1 ); while ( j < n && s [ j ] == ' ' ){ j ++ ; } i = j ; } reverse ( s , 0 , n - 1 ); } int main (){ char * s = ( char * ) malloc ( 100 * sizeof ( char )); gets ( s ); printf ( \"s [%s] \\n \" , s ); reverseWords ( s ); printf ( \"s [%s] \\n \" , s ); return 0 ; } python # -*- coding: utf-8 -*- # for one line class Solution ( object ) : def reverseWords ( self , s ) : \"\"\" :type s: str :rtype: str \"\"\" return ' ' . join ( i for i in s . split ( ' ' )[ ::- 1 ] if i ! = '' )","tags":"Linux","title":"LeetCode [151] Reverse Words in a String"},{"url":"https://yefeihonour.github.io/Delete-Node-in-a-Linked-List.html","text":"Questions Difficulty: Easy Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3 , the linked list should become 1 -> 2 -> 4 after calling your function. Coding python # -*- coding: utf-8 -*- # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution ( object ): def deleteNode ( self , node ): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" node . val = node . next . val node . next = node . next . next","tags":"Linux","title":"LeetCode [237] Delete Node in a Linked List"},{"url":"https://yefeihonour.github.io/Climbing-Stairs.html","text":"Questions Difficulty: Easy You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Coding python # -*- coding: utf-8 -*- class Solution ( object ): def climbStairs ( self , n ): \"\"\" :type n: int :rtype: int \"\"\" if n <= 1 : return 1 elif n == 2 : return 2 else : i , arr = 2 , [ 1 , 2 ] while n > i : arr . append ( arr [ i - 1 ] + arr [ i - 2 ]) i += 1 return arr [ n - 1 ] Java public class Solution { public int climbStairs ( int n ) { if ( n <= 1 ) { return 1 ; } else if ( n == 2 ) { return 2 ; } else { int [] array = new int [ n + 1 ]; array [ 1 ] = 1 ; array [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++) { array [ i ] = array [ i - 1 ] + array [ i - 2 ]; } return array [ n ]; } } }","tags":"Linux","title":"LeetCode [70] Climbing Stairs"},{"url":"https://yefeihonour.github.io/Longest-Substring-Without-Repeating-Characters.html","text":"Questions Difficulty: Medium Given a string, find the length of the longest substring without repeating characters. Examples: Given \"abcabcbb\" , the answer is \"abc\" , which the length is 3 . Given \"bbbbb\" , the answer is \"b\" , with the length of 1 . Given \"pwwkew\" , the answer is \"wke\" , with the length of 3 . Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Coding python # -*- coding: utf-8 -*- class Solution ( object ): def lengthOfLongestSubstring ( self , s ): \"\"\" :type s: str :rtype: int \"\"\" dict , ans , p1 , p2 = {}, 0 , 0 , 0 while p2 < len ( s ): p = dict . get ( s [ p2 ], None ) if p == None : dict [ s [ p2 ]] = p2 p2 += 1 ans = max ( ans , p2 - p1 ) else : while p1 <= p : dict . pop ( s [ p1 ]) p1 += 1 p1 = p + 1 return ans","tags":"Linux","title":"LeetCode [3] Longest Substring Without Repeating Characters"},{"url":"https://yefeihonour.github.io/Reverse-Bits.html","text":"Questions Difficulty: Easy Reverse bits of a given 32 bits unsigned integer. For example, given input 43261596 (represented in binary as 00000010100101000001111010011100 ), return 964176192 (represented in binary as 00111001011110000010100101000000 ). Follow up: If this function is called many times, how would you optimize it? Coding python # -*- coding: utf-8 -*- class Solution ( object ): def reverseBits ( self , n ): \"\"\" :type n: int :rtype: int \"\"\" b = bin ( n )[ 2 :] s = b . zfill ( 32 ) r = int ( s [:: - 1 ], 2 ) return r","tags":"Linux","title":"LeetCode [190] Reverse Bits"},{"url":"https://yefeihonour.github.io/Length-of-Last-Word.html","text":"Questions Difficulty: Easy Given a string s consists of upper/lower-case alphabets and empty space characters ' ' , return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example, Given s = \"Hello World\", return 5. Coding python # -*- coding: utf-8 -*- class Solution ( object ): def lengthOfLastWord ( self , s ): \"\"\" :type s: str :rtype: int \"\"\" if s is None or len ( s ) == 0 : return 0 else : count , i = 0 , len ( s ) - 1 while i >= 0 and s [ i ] == \" \" : i -= 1 while i >= 0 and s [ i ] != \" \" : count += 1 i -= 1 return count","tags":"Linux","title":"LeetCode [58] Length of Last Word"},{"url":"https://yefeihonour.github.io/Remove-Duplicates-from-Sorted-Array.html","text":"Questions Difficulty: Easy Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2] , Your function should return length = 2 , with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length. Coding python # -*- coding: utf-8 -*- class Solution ( object ): def removeDuplicates ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" if nums is None or len ( nums ) == 0 : return 0 elif len ( nums ) == 1 : return 1 else : list , i , end = [], 0 , len ( nums ) - 1 while i <= end : if i == end : list . append ( nums [ i ]) i += 1 else : j = i + 1 if nums [ i ] == nums [ j ]: while j <= end and nums [ i ] == nums [ j ]: j += 1 list . append ( nums [ i ]) i = j for i in range ( 0 , list . __len__ ()): nums [ i ] = list [ i ] return list . __len__ ()","tags":"Linux","title":"LeetCode [26] Remove Duplicates from Sorted Array"},{"url":"https://yefeihonour.github.io/Reverse-Integer.html","text":"Questions Difficulty: Easy Reverse digits of an integer. Example1 : x = 123 , return 321 Example2 : x = - 123 , return - 321 Hint: Have you thought about this? Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer's last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Coding python # -*- coding: utf-8 -*- class Solution ( object ): def reverse ( self , x ): \"\"\" :type x: int :rtype: int \"\"\" n = None if x < 0 : n = - x else : n = x s = str ( n ) s = s [:: - 1 ] if x < 0 : n = - int ( s ) else : n = int ( s ) if n >= 2147483647 or n <= - 2147483647 - 1 : return 0 return n","tags":"Linux","title":"LeetCode [7] Reverse Integer"},{"url":"https://yefeihonour.github.io/Rotate-Array.html","text":"Questions Difficulty: Easy Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Hint: Could you do it in-place with O(1) extra space? Coding Java public class Solution { public void swap ( int [] array , int a , int b ) { int t = array [ a ]; array [ a ] = array [ b ]; array [ b ] = t ; } public void reverse ( int [] array , int start , int end ) { if ( array == null || array . length <= 1 ) { return ; } for ( int i = start , j = end ; i < j ; i ++, j --) { swap ( array , i , j ); } } public void rotate ( int [] nums , int k ) { if ( k == 0 ) { return ; } int n = nums . length ; if ( k > n ) { k = k % n ; } reverse ( nums , 0 , n - 1 - k ); reverse ( nums , n - k , n - 1 ); reverse ( nums , 0 , n - 1 ); } } python # -*- coding: utf-8 -*- class Solution ( object ): def rotate ( self , nums , k ): \"\"\" :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. \"\"\" if k == 0 : return n = len ( nums ) if k > n : k = k % n self . reverse ( nums , 0 , n - 1 - k ) self . reverse ( nums , n - k , n - 1 ) self . reverse ( nums , 0 , n - 1 ) def swap ( self , array , a , b ): t = array [ a ] array [ a ] = array [ b ] array [ b ] = t def reverse ( self , array , start , end ): if array is None or len ( array ) <= 1 : return i , j = start , end while i < j : self . swap ( array , i , j ) i , j = i + 1 , j - 1 if __name__ == \"__main__\" : nums = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] solution = Solution () print nums solution . rotate ( nums , 4 ) print nums","tags":"Linux","title":"LeetCode [189] Rotate Array"},{"url":"https://yefeihonour.github.io/Add-Two-Numbers.html","text":"Questions Difficulty: Medium You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Coding python # -*- coding: utf-8 -*- # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution ( object ): def addTwoNumbers ( self , l1 , l2 ): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" l = l1 ll = l2 flag = 0 temp = None while l1 is not None and l2 is not None : l1 . val = l1 . val + l2 . val + flag flag = l1 . val / 10 l1 . val %= 10 temp = l1 l1 = l1 . next l2 = l2 . next if l2 is not None : temp . next = l2 l1 = l2 while l1 is not None : l1 . val += flag flag = l1 . val / 10 l1 . val %= 10 temp = l1 l1 = l1 . next if flag == 1 : temp . next = ll ll . val = 1 ll . next = None return l","tags":"Linux","title":"LeetCode [2] Add Two Numbers"},{"url":"https://yefeihonour.github.io/Two-Sum.html","text":"Questions Difficulty: Easy Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Coding python # -*- coding: utf-8 -*- class Solution ( object ): def twoSum ( self , nums , target ): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" for i in range ( 0 , len ( nums )): x = nums [ i ] if ( target - x ) in nums [ i + 1 :]: return [ i , nums [ i + 1 :] . index ( target - x ) + i + 1 ]","tags":"Linux","title":"LeetCode [1] Two Sum"}]}